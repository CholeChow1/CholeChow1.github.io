---
layout:     post
title:      java数据结构之选择排序！
subtitle:   java简单的数据结构
date:       2018-12-14
author:     李勇
header-img: img/post-12-14-6.png
catalog: true
tags:
    - Java
    - 数据结构
    - 选择排序
---

## 1st ##
**选择排序（Selection sort）是一种简单直观的排序算法。**

它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，
然后放到已排序序列的末尾。以此类推，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法。

**选择排序输出的是原序列的一个重排 <a1*,a2*,a3*,...,an*>；，使得 a1*<=a2*<=a3*<=...<=an***

排序算法有很多，包括插入排序，冒泡排序，堆排序，归并排序，选择排序，计数排序，基数排序，桶排序，快速排序等。插入排序，堆排序，
选择排序，归并排序和快速排序，
冒泡排序都是比较排序，它们通过对数组中的元素进行比较来实现排序其他排序算法则是利用非比较的其他方法来获得有关输入数组的排序信息。

**思想**

n 个记录的文件的直接选择排序可经过 n-1 趟直接选择排序得到有序结果：

①初始状态：无序区为 R[1..n]，有序区为空。

②第 1 趟排序

在无序区 R[1..n] 中选出关键字最小的记录 R[k]，将它与无序区的第 1 个记录 R[1] 交换，使 R[1..1] 和 R[2..n] 分别变
为记录个数增加 1 个的新有序区和记录个数减少 1 个的新无序区。

……

③第 i 趟排序

第 i 趟排序开始时，当前有序区和无序区分别为 R[1..i-1] 和 R(i..n）。该趟排序从当前无序区中选出关键字最小的记录 R[k]，
将它与无序区的第 1 个记录 R 交换，使 R[1..i] 和 R 分别变为记录个数增加 1 个的新有序区和记录个数减少 1 个的新无序区。

**解释**

对比数组中前一个元素跟后一个元素的大小，如果后面的元素比前面的元素小则用一个变量 k 来记住他的位置，接着第二次比较，
前面 “后一个元素” 现变成了 “前一个元素”，继续跟他的“后一个元素” 进行比较如果后面的元素比他要小则用变量 k 记住它在数组中的位置(下标)，
等到循环结束的时候，我们应该找到了最小的那个数的下标了，然后进行判断，如果这个元素的下标不是第一个元素的下标，就让第一个元素跟他交换一下值，
这样就找到整个数组中最小的数了。
然后找到数组中第二小的数，让他跟数组中第二个元素交换一下值，以此类推。

**算法性能**

**时间复杂度**

选择排序的交换操作介于 0 和 (n - 1） 次之间。选择排序的比较操作为 n (n - 1） / 2 次之间。选择排序的赋值操作介于 0 和 3 (n - 1） 次之间。

比较次数 O(n^2），比较次数与关键字的初始状态无关，总的比较次数 N=(n-1）+(n-2）+...+1=n*(n-1）/2。交换次数 O(n），最好情况是，已经有序，
交换 0 次；最坏情况交换 n-1 次，逆序交换 n/2 次。交换次数比冒泡排序少多了，由于交换所需 CPU 时间比比较所需的 CPU 时间多，
n 值较小时，选择排序比冒泡排序快。

**稳定性**

选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第 n-1 个元素，
第 n 个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果一个元素比当前元素小，而该小的元素又出现在一个和当前元素相等的元素后面，
那么交换后稳定性就被破坏了。比较拗口，举个例子，序列 5 8 5 2 9，我们知道第一遍选择第 1 个元素 5 会和 2 交换，那么原序列中两个 5 的相对前后顺序就
被破坏了，
所以选择排序是一个不稳定的排序算法。

## 2st ##
**java代码如下：**
   ```
   package 数据结构;

public class xuanzepaixu {
  public static void sort(long arr[]){
	  long temp=0;//中间变量用来交换数据
	  int k;//定义一个选择变量来进行选择
	  for(int i=0;i<arr.length-1;i++){//循环
		  k=i;//每次循环都将这一次i的值赋给k
		  for(int j=i;j<arr.length;j++){//数据比较
			  if(arr[k]>arr[j]){//效率比冒泡高，如果arr[k]后面的数据比它小，则交换数据
				  temp=arr[j];
				  arr[j]=arr[k];
				  arr[k]=temp;
			  }
		  }
		  arr[i]=arr[k];//通过选择k找到每一轮的最小值arr[k]赋给arr[i]，即顺序已经排好
	  }
  }
}

```

----


  
## 3st ##
**测试：**
```
package 数据结构;

public class Testxuanzepaixu {
    public static void main(String args[]){
    	 long arr[]=new long[6];
	     arr[0]=2;
	     arr[1]=1;
	     arr[2]=5;
	     arr[3]=3;
	     arr[4]=8;
	     arr[5]=0;
	     xuanzepaixu.sort(arr);
	     for(int i=0;i<arr.length;i++){
	    	 System.out.println(arr[i]);
	     }
   }
    }


```

**输出结果如下**

![](https://raw.githubusercontent.com/CholeChow1/CholeChow1.github.io/master/img/xuanzepaixu.png)

好啦,这次就到这里啦，有问题可以和我留言哦！ 

下面日常放一张杂图 嘻嘻嘻

![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1544804911691&di=025e21427395726d9a53212744a5fac3&imgtype=0&src=http%3A%2F%2Fmmbiz.qpic.cn%2Fmmbiz_png%2FVB7kWrDrP9nd0f1DmPa4g8jLibkW1ZON0mPiaA9tiaXyibYMnrShqaW5dwN9O9p3mvR0ohP2A2icbOX33JVb0ZFl5Gw%2F640%3Fwx_fmt%3Dpng)
